if (not game:IsLoaded()) then
	game.Loaded:Wait();
end

local Cmd = (getgenv) 
	or function() return _G end

local Speed = tick()
local Admins = {}

local Settings = {
	Prefix	 = (";");
	ChatPrefix = ("!");
	Seperator = (",");
	Version = ("Beta 1.0");

	CustomUI = (Cmd().CustomUI) or "rbxassetid://18617417654",

	Waypoints = {},
	Events = {
		["AutoExecute"] = {},
		["Chatted"] = {},
		["CharacterAdded"] = {},
		["Died"] = {},
		["Damaged"] = {},
		["PlayerRemoved"] = {},
	},

	Theme = {
		Mode = "Dark",
		Transparency = 0,
		Primary = Color3.fromRGB(15, 15, 15),
		Secondary = Color3.fromRGB(15, 15, 15),
		Actions = Color3.fromRGB(15, 15, 15),
		Component = Color3.fromRGB(15, 15, 15),
		Highlight = Color3.fromRGB(178, 34, 34),
		ScrollBar = Color3.fromRGB(15, 15, 15),
		Title = Color3.fromRGB(178, 34, 34),
		Description = Color3.fromRGB(178, 34, 34),
		Shadow = Color3.fromRGB(0, 0, 0),
		Outline = Color3.fromRGB(15, 15, 15),
		Icon = Color3.fromRGB(178, 34, 34)
	},

	Toggles = {
		FillCap = true,
		Developer = false,
		Notify = true,
		Popups = true,
		Interfere = true,
		Recommendation = true,
		InternalUI = false,
		StaffNotifier = true,
		IgnoreSeated = true,
	},
}

local Connect = (game.Loaded.Connect);
local CWait = (game.Loaded.Wait);
local Clone = (game.Clone);
local Destroy = (game.Destroy);
local Changed = (game.GetPropertyChangedSignal);
local GetService = (function(Property)
	local Service = (game.GetService);
	local Reference = (cloneref) 
		or function(reference) return reference end

	return Reference( Service(game, Property) );
end)

local Services = ({
	Players = GetService("Players"),
	Lighting = GetService("Lighting"),
	Core = GetService("CoreGui"),
	Teams = GetService("CoreGui"),
	Insert = GetService("InsertService"),
	Http = GetService("HttpService"),
	Run = GetService("RunService"),
	Input = GetService("UserInputService"),
	Tween = GetService("TweenService"),
	Teleport = GetService("TeleportService"),
	Chat = GetService("TextChatService"),
	Replicated = GetService("ReplicatedStorage"),
	Market = GetService("MarketplaceService"),
	Starter = GetService("StarterGui"),
	ContextActionService = GetService("ContextActionService"),
	Sound = GetService("SoundService")
}); 

local Methods = ({
	Get = function(URL) 
		local Method = (game.HttpGet)
		return Method(game, URL);
	end,

	Parent = function(Child) 
		xpcall(function() 
			Child.Parent = (gethui and gethui()) or Services.Core
		end, function() 
			Child.Parent = Services.Players.LocalPlayer["PlayerGui"];
		end)
	end,
}); 

local Check = (function(Type) 
	if Type == "File" then
		return (isfile and isfolder and writefile and readfile)
	elseif Type == "Hook" then
		return (hookmetamethod or hookfunction);
	end
end);

local LocalPlayer = Services.Players.LocalPlayer
local Character = LocalPlayer.Character
local Backpack = LocalPlayer.Backpack
local Humanoid = (Character and Character:FindFirstChildOfClass("Humanoid"))
local Root = (Character and Character:FindFirstChild("HumanoidRootPart"))

Connect(LocalPlayer.CharacterAdded, function(Char) 
	Character = (Char);
	Humanoid = Character:WaitForChild("Humanoid");
	Root = (Character:FindFirstChild("HumanoidRootPart"));

	Backpack = (LocalPlayer.Backpack);
end)

local Lower, Split, Sub, GSub, Find, Match, Format, Blank = 
	string.lower, string.split, string.sub, string.gsub, string.find, string.match, string.format, "", ""

local Unpack, Insert, Discover, Concat, FullArgs = 
	table.unpack, table.insert, table.find, table.concat, {}

local Spawn, Delay, Wait = 
	task.spawn, task.delay, task.wait 

local JSONEncode, JSONDecode, GenerateGUID = 
	Services.Http.JSONEncode, Services.Http.JSONDecode, Services.Http.GenerateGUID

local Mouse, PlayerGui = 
	LocalPlayer:GetMouse(), LocalPlayer.PlayerGui

local Camera = workspace.CurrentCamera
local RespectFilteringEnabled = Services.Sound.RespectFilteringEnabled 
local LegacyChat = (Services.Chat.ChatVersion == Enum.ChatVersion.LegacyChatService)

local GetModule = function(Name) 
	return (Methods.Get(Format("https://raw.githubusercontent.com/lxte/modules/main/cmd/%s", Name)))
end

-- another check in case humanoid not found lmao
if (not Character) or (not Humanoid) or (not Root) then 
	Spawn(function() 
		Character = (Character or CWait(LocalPlayer.CharacterAdded))
		Humanoid = Character:FindFirstChildOfClass("Humanoid");
		Root = Character:FindFirstChild("HumanoidRootPart");
	end)
end

-- :: INSERT[UI] ::
local UI = (Services.Run:IsStudio() and script.Parent) or Services.Insert:LoadLocalAsset(Settings.CustomUI);

local Assets = UI.Assets 
local Notification = UI.Frame 
local CommandBar = UI.Cmd.CommandBar 
local Tab = UI.Tab 

local Components = Assets.Components
local Features = Assets.Features 

local Autofill = CommandBar.Autofill
local Search = CommandBar.Search 
local BarShadow = CommandBar.Shadow 

local Input = Search.TextBox 
local Recommend = Search.Recommend 
local Press = Search.Press

local Protected = {} 

if Check("Hook") then 
	xpcall(function() 
		--// untested since no free exec has hooking lol hopefully doesnt break...
		for Index, Descendant in next, UI:GetDescendants() do 
			Protected[Descendant] = ("RobloxGui");
		end

		Connect(UI.DescendantAdded, function(Descendant) 
			Protected[Descendant] = ("RobloxGui");
		end)

		local Original
		local isCaller = checkcaller or function() 
			return true
		end

		Original = hookmetamethod(game, "__tostring", function(self) 
			if self and Protected[self] and not isCaller() then 
				return Protected[self]
			end 
			return Original
		end)	

	end, function(Result)
		if Settings.Toggles.Developer then 
			warn(Format("Error occured setting gui protection (%s)", Result))
		end
	end)
end
Methods.Parent(UI);
UI.Name = (GenerateGUID(Services.Http));
Tab.Name = (GenerateGUID(Services.Http));

-- :: FUNCTIONS :: --
local UDimMultiply = function(UDim, Amount) 
	local Values = {
		UDim.X.Scale * Amount;
		UDim.X.Offset * Amount;
		UDim.Y.Scale * Amount;
		UDim.Y.Offset * Amount;
	}

	return UDim2.new(Unpack(Values))
end

local Minimum = function(Table, Minimum)
	local New = {}
	if Table then
		for i,v in next, Table do
			if i == Minimum or i > Minimum then
				Insert(New, v);
			end
		end
	end
	return New
end

local Chat = function(Message)
	if LegacyChat then
		Services.Replicated.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(Message, "All");
	else
		Services.Chat.TextChannels.RBXGeneral:SendAsync(Message);
	end
end

local Foreach = function(Table, Func, Loop)
	for Index, Value in next, Table do
		pcall(function()
			if Loop and typeof(Value) == 'table' then
				for Index2, Value2 in next, Value do
					Func(Index2, Value2)
				end
			else
				Func(Index, Value)
			end
		end)
	end
end

local FindTable = function(Table, Input)	
	for Index, Value in next, Table do
		if Value == Input then
			return Value
		end
	end
end

local MultiSet = function(Object, Properties)
	for Index, Property in next, Properties do
		Object[Index] = (Property);
	end

	return Object
end

local Create = function(ClassName, Properties, Children)
	local Object = Instance.new(ClassName)

	for i, Property in next, Properties or {} do
		Object[i] = Property
	end

	for i, Children in next, Children or {} do
		Children.Parent = Object
	end

	return Object
end

local SetSRadius = setsimulationradius or function(Radius, MaxRadius) 
	Spawn(function() 
		LocalPlayer.SimulationRadius = Radius
		LocalPlayer.MaxSimulationDistance = MaxRadius
	end)
end

local AttachName = GenerateGUID(Services.Http);
local Attach = function(Part, Target) 
	if (Part and Part:IsA("BasePart") and not Part.Anchored) then 
		local ModelDescendant = Part:FindFirstAncestorOfClass("Model") 
		SetSRadius(9e9, 9e9)

		if ModelDescendant then 
			if Services.Players:GetPlayerFromCharacter(ModelDescendant) then 
				return
			end
		end

		local Attachment = Instance.new("Attachment");
		local Position = Instance.new("AlignPosition");
		local Orientation = Instance.new("AlignOrientation");
		local Attachment2 = Instance.new("Attachment");

		Attachment.Name = (AttachName);
		Position.Name = (AttachName);
		Orientation.Name = (AttachName);
		Attachment2.Name = (AttachName);

		Attachment.Parent = Part;
		Position.Parent = Part;
		Orientation.Parent = Part;
		Attachment2.Parent = (Target or Root);

		Position.Responsiveness = (200);
		Orientation.Responsiveness = (200);

		Position.MaxForce = (9e9);
		Orientation.MaxTorque = (9e9);

		Position.Attachment0 = Attachment
		Position.Attachment1 = Attachment2
		Orientation.Attachment1 = Attachment2
		Orientation.Attachment0 = Attachment

		return Attachment, Position, Orientation, Attachment2
	end
end

local IsStaff = function(Player)
	local StaffRoles = { "owner", "admin", "staff", "mod", "founder", "manager", "dev", "president", "leader" , "supervisor", "chairman", "supervising" };
	local CurrentRole = Player:GetRoleInGroup(game.CreatorId);

	for Index, Role in next, StaffRoles do 
		if Lower(CurrentRole):find(Role) then
			return true, CurrentRole 
		end 
	end
end

local Tween = function(Object, Speed, Properties,  Info)
	local Info = Info or {}
	local Style, Direction = 
		(Info["EasingStyle"]) or Enum.EasingStyle.Sine,
	(Info["EasingDirection"]) or Enum.EasingDirection.Out

	return Services.Tween:Create(Object, TweenInfo.new(Speed, Style, Direction), Properties):Play()
end

local SetRig = function(Type)
	local Avatar = GetService("AvatarEditorService")
	Avatar:PromptSaveAvatar(Humanoid.HumanoidDescription, Enum.HumanoidRigType[Type])
	CWait(Avatar.PromptSaveAvatarCompleted)
	Command.Parse(true, "respawn")
end

local GetClasses = function(Ancestor, Class, GetChildren)
	local Results = {};

	for Index, Descendant in next, (GetChildren and Ancestor:GetChildren()) or Ancestor:GetDescendants() do
		if Descendant:IsA(Class) then
			Insert(Results, Descendant)
		end
	end 

	return Results
end

local SetNumber = function(Input, Minimum, Max)
	Minimum = tonumber(Minimum) or -math.huge
	Max = tonumber(Max) or math.huge

	if Input then
		local Numbered = tonumber(Input);

		if Numbered and ((Numbered == (Minimum or Max) or (Numbered < Max) or (Numbered > Minimum))) then
			return Numbered;
		elseif Lower(Input) == "inf" then
			return Max;
		else 
			return 0;
		end
	else
		return 0;
	end
end

local GetCharacter = function(Player)
	return (Player and Player.Character)
end

local GetRoot = function(Player)
	local Char = GetCharacter(Player)
	return (Char and Char:FindFirstChild("HumanoidRootPart"))
end

local GetHumanoid = function(Player)
	local Char = GetCharacter(Player)
	return (Char and Char:FindFirstChildOfClass("Humanoid"))
end

PArguments = {
	["all"] = function() 
		return (Services.Players:GetPlayers());
	end,

	["others"] = function()
		local Targets = {}
		Foreach(Services.Players:GetPlayers(), function(Index, Player) 
			if (Player ~= LocalPlayer) then
				Insert(Targets, Player)
			end
		end)
		return Targets
	end, 

	["me"] = function()
		return { LocalPlayer }
	end,

	["random"] = function()
		local Amount = Services.Players:GetPlayers()
		return { Amount[math.random(1, #Amount)] }
	end,

	["npc"] = function()
		local Targets = {}
		for Index, Model in next, GetClasses(workspace, "Model") do 
			if (Model:FindFirstChildOfClass("Humanoid") and 
				not Services.Players:GetPlayerFromCharacter(Model))  then
				Insert(Targets, Model)
			end
		end
		return Targets
	end, 

	["seated"] = function()
		local Targets = {}
		for Index, Player in next, GetClasses(Services.Players, "Player") do
			local PHumanoid = GetHumanoid(Player)
			if (PHumanoid and PHumanoid.Sit) then
				Insert(Targets, Player)
			end
		end
		return Targets
	end, 

	["stood"] = function()
		local Targets = {}
		for Index, Player in next, GetClasses(Services.Players, "Player") do
			local PHumanoid = GetHumanoid(Player)
			if (PHumanoid and not PHumanoid.Sit) then
				Insert(Targets, Player)
			end
		end
		return Targets
	end,

	["closest"] = function()
		local Targets = {}
		local ClosestDistance = 9e9
		local ClosestPlayer
		for Index, Player in next, GetClasses(Services.Players, "Player") do 
			local Distance = Player:DistanceFromCharacter(Root.Position)
			if (Player ~= LocalPlayer) and (Distance < ClosestDistance) then
				ClosestDistance = Distance
				ClosestPlayer = Player
			end
		end
		return { ClosestPlayer }
	end,

	["farthest"] = function()
		local Targets = {}
		local FurthestDistance, FurthestPlayer = 0, nil
		for Index, Player in next, GetClasses(Services.Players, "Player") do 
			local Distance = Player:DistanceFromCharacter(Root.Position)
			if (Player ~= LocalPlayer) and (Distance > FurthestDistance) then
				FurthestDistance = (Distance)
				FurthestPlayer = (Player)
			end
		end
		return { FurthestPlayer }
	end,

	["enemies"] = function()
		local Targets = {}
		for Index, Player in next, GetClasses(Services.Players, "Player") do 
			if (Player.Team ~= LocalPlayer.Team) then
				Insert(Targets, Player)
			end
		end
		return Targets
	end,

	["dead"] = function()
		local Targets = {}
		for Index, Player in next, GetClasses(Services.Players, "Player") do 
			local PHumanoid = GetHumanoid(Player);
			if (PHumanoid and PHumanoid.Health == 0) then
				Insert(Targets, Player)
			end
		end
		return Targets
	end,


	["alive"] = function()
		local Targets = {}
		for Index, Player in next, GetClasses(Services.Players, "Player") do 
			local PHumanoid = GetHumanoid(Player);
			if (PHumanoid and PHumanoid.Health > 0) then
				Insert(Targets, Player)
			end
		end
		return Targets
	end,

	["friends"] = function()
		local Targets = {}
		for Index, Player in next, GetClasses(Services.Players, "Player") do 
			if (Player:IsFriendsWith(LocalPlayer.UserId)) and (LocalPlayer ~= Player) then
				Insert(Targets, Player)
			end
		end
		return Targets
	end,

	["nonfriends"] = function()
		local Targets = {}
		for Index, Player in next, GetClasses(Services.Players, "Player") do 
			if (not Player:IsFriendsWith(LocalPlayer.UserId)) and (LocalPlayer ~= Player) then
				Insert(Targets, Player)
			end
		end
		return Targets
	end,
}

local GetPlayer = function(Target)
	local Target = Lower(Target);
	local PlayerType = PArguments[Target];

	if PlayerType then
		return PlayerType();
	else
		local Specific = {}
		Foreach(Services.Players:GetPlayers(), function(Index, Player) 
			local Name, Display = Lower(Player.Name), Lower(Player.DisplayName)
			if Sub(Name, 1, #Target) == Target then
				Insert(Specific, Player)

			elseif Sub(Display, 1, #Target) == Target then
				Insert(Specific, Player)
			end
		end)
		return Specific
	end
end

local Fling = function(Targets) 
	local S, Result = pcall(function() 
		local Flung = (0)

		local Position = Root.CFrame
		local Velocity = Root.Velocity
		local DestroyHeight = workspace.FallenPartsDestroyHeight

		for Index, Target in next, (Targets) do 
			local TCharacter = GetCharacter(Target);
			local THumanoid = GetHumanoid(Target);
			local TRoot = GetRoot(Target);

			if (THumanoid) and (TRoot) and (Root) and (THumanoid.Health > 0) and (Target ~= LocalPlayer) then 
				if not (Settings.Toggles.IngoreSeated and THumanoid.Sit) then
					local Timer = tick()
					local AlreadyFlung = (TRoot and TRoot.Velocity.Magnitude > 200)

					Camera.CameraSubject = (THumanoid);
					workspace.FallenPartsDestroyHeight = (-math.huge);

					repeat Wait();
						local Offset = TRoot.Velocity * Random.new():NextNumber(-0.2, 2.5)
						Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
						Root.Velocity = Vector3.new(0, 1e6, 0)
						Root.CFrame = CFrame.new(TRoot.Position + Offset)
					until (not TCharacter) or (not Root) or (Settings.Toggles.IgnoreSeated and THumanoid.Sit) or (TRoot.Velocity.Magnitude > 200) or (THumanoid.Health <= 0) or (tick() - Timer >= 2)
					if (not AlreadyFlung) and (TRoot and TRoot.Velocity.Magnitude > 200) then 
						Flung += 1
					end
				end
			end
		end

		repeat 
			local Old = Position * CFrame.new(0, 1, 0);
			Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
			Camera.CameraSubject = (Humanoid)
			Root.CFrame = (Old)
			Character:SetPrimaryPartCFrame(Old)

			for Index, BodyPart in next, GetClasses(Character, "BasePart", true) do 
				BodyPart.Velocity = Vector3.new(0, 0, 0)
				BodyPart.RotVelocity = Vector3.new(0, 0, 0)
			end

			CWait(Services.Run.Heartbeat);
		until not Root or (Root.Position - Position.p).Magnitude < 20
		workspace.FallenPartsDestroyHeight = DestroyHeight
		return Flung
	end)
	return Result
end

local SetFly
local ThumbstickMoved

Spawn(function()
	local BodyGyro = Instance.new("BodyGyro")
	BodyGyro.maxTorque = Vector3.new(1, 1, 1) * 10 ^ 6
	BodyGyro.P = 10 ^ 6

	local BodyVelocity = Instance.new("BodyVelocity")
	BodyVelocity.maxForce = Vector3.new(1, 1, 1) * 10 ^ 6
	BodyVelocity.P = 10 ^ 4

	local Flying = false
	local Movement = { forward = 0, backward = 0, right = 0, left = 0 }

	local function SetFlying(Bool)
		Flying = Bool

		BodyGyro.Parent = (Flying and Root) or nil
		BodyVelocity.Parent = (Flying and Root) or nil
		BodyVelocity.Velocity = Vector3.new()

		if (Flying) then
			BodyGyro.CFrame = Root.CFrame
		end
	end

	local FlySpeed = 3

	local function ModifyMovement(newMovement)
		Movement = newMovement or Movement
		if (Flying) then
			local isMoving = Movement.right + Movement.left + Movement.forward + Movement.backward > 0
		end
	end

	local function MovementBind(actionName, InputState, inputObject)
		if (InputState == Enum.UserInputState.Begin) then
			Movement[actionName] = 1

			ModifyMovement()
		elseif (InputState == Enum.UserInputState.End) then
			Movement[actionName] = 0

			ModifyMovement()
		end

		return Enum.ContextActionResult.Pass
	end

	Services.ContextActionService:BindAction("forward", MovementBind, false, Enum.PlayerActions.CharacterForward)
	Services.ContextActionService:BindAction("backward", MovementBind, false, Enum.PlayerActions.CharacterBackward)
	Services.ContextActionService:BindAction("left", MovementBind, false, Enum.PlayerActions.CharacterLeft)
	Services.ContextActionService:BindAction("right", MovementBind, false, Enum.PlayerActions.CharacterRight)

	local TouchFrame
	if PlayerGui:FindFirstChild("TouchGui") then
		TouchFrame = PlayerGui.TouchGui:FindFirstChild("TouchControlFrame")
	end

	local DeadZone = 0.15
	local DeadZoneNormalized = 1 - DeadZone

	local isTouchOnThumbstick = function(Position)
		if not TouchFrame then
			return false
		end
		local ClassicFrame = TouchFrame:FindFirstChild("ThumbstickFrame")
		local DynamicFrame = TouchFrame:FindFirstChild("DynamicThumbstickFrame")
		local StickFrame = (ClassicFrame and ClassicFrame.Visible) and ClassicFrame or DynamicFrame

		if (StickFrame) then
			local StickPosition = StickFrame.AbsolutePosition
			local StickSize = StickFrame.AbsoluteSize
			return Position.X >= StickPosition.X and Position.X <= (StickPosition.X + StickSize.X) and
				Position.Y >= StickPosition.Y and
				Position.Y <= (StickPosition.Y + StickSize.Y)
		end
		return false
	end

	Connect(Services.Input.TouchStarted, function(touch, gameProcessedEvent)
		ThumbstickMoved = isTouchOnThumbstick(touch.Position)
	end)

	Connect(Services.Input.TouchEnded, function(touch, gameProcessedEvent)
		if ThumbstickMoved then
			ThumbstickMoved = (false);
			ModifyMovement({forward = 0, backward = 0, right = 0, left = 0})
		end
	end)

	Connect(Services.Input.TouchMoved, function(touch, gameProcessedEvent)
		if ThumbstickMoved then
			local MouseVector = (Humanoid.MoveDirection)
			local LeftRight = (MouseVector.X)
			local ForeBack = (MouseVector.Z)

			Movement.left = LeftRight < -DeadZone and -(LeftRight - DeadZone) / DeadZoneNormalized or 0
			Movement.right = LeftRight > DeadZone and (LeftRight - DeadZone) / DeadZoneNormalized or 0

			Movement.forward = ForeBack < -DeadZone and -(ForeBack - DeadZone) / DeadZoneNormalized or 0
			Movement.backward = ForeBack > DeadZone and (ForeBack - DeadZone) / DeadZoneNormalized or 0
			ModifyMovement()
		end
	end)

	local Updated = function(dt)
		if (Flying) then
			local Position = (workspace.CurrentCamera.CFrame);
			local Direction =
				Position.rightVector * (Movement.right - Movement.left) +
				Position.lookVector * (Movement.forward - Movement.backward)

			if (Direction:Dot(Direction) > 0) then
				Direction = (Direction.unit);
			end

			BodyGyro.CFrame = Position
			BodyVelocity.Velocity = Direction * Humanoid.WalkSpeed * FlySpeed
		end

	end

	SetFly = function(Boolean, SpeedValue)
		FlySpeed = SpeedValue or 1
		SetFlying(Boolean)
		Connect(Services.Run.RenderStepped, Updated)
	end
end)

Tab.Visible = false
CommandBar.Actions.Description.Text = Settings.Version
CommandBar.Visible = false
CommandBar.GroupTransparency = 1

-- :: LIBRARY[UI] :: -- 
local Type
local API     = {};
local Library = { Tabs = {} };
local Fill    = {};
local Globals  = {};
local Feature = {}

local Add = function(Global, Value) 
	Globals[Global] = Value
end

local Get = function(Global) 
	return Globals[Global]
end

local Refresh = function(Global, NewValue) 
	Add(Global, false);
	Wait(.2);
	Add(Global, NewValue);
end

local Animate = {
	Set = function(Component, Title, Description)
		local Labels = (Component.Frame);
		local TLabel, DLabel = (Labels.Title), (Labels.Description);

		if Title then
			TLabel.Text = Title 
		else
			Destroy(TLabel);
		end

		if Description then
			DLabel.Text = Description 
		else
			Destroy(DLabel);
		end
	end,

	Open = function(Window, Transparency, Size, CheckVisible, Center, Amount)
		if (CheckVisible and not Window.Visible) or not CheckVisible then
			local Size = (Size or Window.Size);
			local NewSize = UDimMultiply(Size, Amount or 1.1);
			local Outline = Window:FindFirstChildOfClass("UIStroke");

			MultiSet(Outline, { Transparency = 1 })
			MultiSet(Window, {
				Size = NewSize,
				GroupTransparency = 1,
				Visible = true,
				Position = (Center and UDim2.fromScale(0.5, 0.5)) or Window.Position
			})

			Tween(Outline, .25, { Transparency = 0.8 })
			Tween(Window, .25, {
				Size = Size,
				GroupTransparency = Transparency or 0,
			})
		end
	end,

	Close = function(Window, Amount, Invisible)
		Spawn(function() 
			local Size = (Window.Size);
			local NewSize = UDimMultiply(Size, Amount or 1.1);
			local Outline = Window:FindFirstChildOfClass("UIStroke");

			Tween(Outline, .25, { Transparency = 1 })
			Tween(Window, .25, {
				Size = NewSize,
				GroupTransparency = 1,
			})

			if Invisible then
				Wait(.25);
				Window.Visible = false
			end
		end)
	end,

	Drag = function(Window)
		if Window then
			local Dragging;
			local DragInput;
			local Start;
			local StartPosition;

			local function Update(input)
				local delta = input.Position - Start
				local Screen = UI.AbsoluteSize
				local Absolute = Window.AbsoluteSize

				Window.Position = UDim2.new(
					StartPosition.X.Scale, 
					math.clamp(StartPosition.X.Offset + delta.X, -(Screen.X / 2) + (Absolute.X / 2), (Screen.X / 2) - (Absolute.X / 2)),
					StartPosition.Y.Scale, 
					math.clamp(StartPosition.Y.Offset + delta.Y, -(Screen.Y / 2) + (Absolute.Y / 2), (Screen.Y / 2) - (Absolute.Y / 2))
				)
			end

			Connect(Window.InputBegan, function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch and not Type then
					Dragging = true
					Start = Input.Position
					StartPosition = Window.Position

					Connect(Input.Changed, function()
						if Input.UserInputState == Enum.UserInputState.End then
							Dragging = false
						end
					end)
				end
			end)

			Connect(Window.InputChanged, function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseMovement or Input.UserInputType == Enum.UserInputType.Touch and not Type then
					DragInput = Input
				end
			end)

			Connect(Services.Input.InputChanged, function(Input)
				if Input == DragInput and Dragging and not Type then
					Update(Input)
				end
			end)
		end
	end,
};

local Color = function(Color, Factor, Mode)
	Mode = Mode or Settings.Theme.Mode

	if Mode == "Light" then
		return Color3.fromRGB((Color.R * 255) - Factor, (Color.G * 255) - Factor, (Color.B * 255) - Factor)
	else
		return Color3.fromRGB((Color.R * 255) + Factor, (Color.G * 255) + Factor, (Color.B * 255) + Factor)
	end
end

function Library:CreateWindow(Config: { Title: string }) 
	local Window = Clone(Tab);
	local Animations = {};
	local Component = {};

	local Actions = Window.Actions 
	local Tabs = Window.Tabs
	local Topbar = Window.Topbar

	local TabName = Topbar.Title 
	local WindowName = Topbar.Description 
	local SearchBox = Topbar.SearchBox 

	local Previous = "Home"
	local Current = "Home"

	local Maximized = (false);
	local Minimzied = (false);

	local Minimum, Maximum = Vector2.new(204, 220), Vector2.new(9e9, 9e9)

	local List = { 
		BottomLeft = { X = Vector2.new(-1, 0),   Y = Vector2.new(0, 1)};
		BottomRight = { X = Vector2.new(1, 0),    Y = Vector2.new(0, 1)};
	}

	Spawn(function()
		local MousePos, Size, UIPos = nil, nil, nil

		if Window and Window:FindFirstChild("Background") then
			local Positions = Window:FindFirstChild("Background")

			for Index, Types in next, Positions:GetChildren() do
				Connect(Types.InputBegan, function(Input)
					if Input.UserInputType == Enum.UserInputType.MouseButton1 then
						Type = Types
						MousePos = Vector2.new(Mouse.X, Mouse.Y)
						Size = Window.AbsoluteSize
						UIPos = Window.Position
					end
				end)

				Connect(Types.InputEnded, function(Input)
					if Input.UserInputType == Enum.UserInputType.MouseButton1 then
						Type = nil
					end
				end)
			end
		end

		local Resize = function(Delta)
			if Type and MousePos and Size and UIPos and Window:FindFirstChild("Background")[Type.Name] == Type then
				local Mode = List[Type.Name]
				local NewSize = Vector2.new(Size.X + Delta.X * Mode.X.X, Size.Y + Delta.Y * Mode.Y.Y)
				NewSize = Vector2.new(math.clamp(NewSize.X, Minimum.X, Maximum.X), math.clamp(NewSize.Y, Minimum.Y, Maximum.Y))

				local AnchorOffset = Vector2.new(Window.AnchorPoint.X * Size.X, Window.AnchorPoint.Y * Size.Y)
				local NewAnchorOffset = Vector2.new(Window.AnchorPoint.X * NewSize.X, Window.AnchorPoint.Y * NewSize.Y)
				local DeltaAnchorOffset = NewAnchorOffset - AnchorOffset

				Window.Size = UDim2.new(0, NewSize.X, 0, NewSize.Y)

				local NewPosition = UDim2.new(
					UIPos.X.Scale, 
					UIPos.X.Offset + DeltaAnchorOffset.X * Mode.X.X,
					UIPos.Y.Scale,
					UIPos.Y.Offset + DeltaAnchorOffset.Y * Mode.Y.Y
				)
				Window.Position = NewPosition
			end
		end

		Connect(Mouse.Move, function()
			if Type then
				pcall(function()
					Resize(Vector2.new(Mouse.X, Mouse.Y) - MousePos)
				end)
			end
		end)
	end)

	WindowName.Text = (Config.Title);
	Window.Parent = (UI);
	Window.Name = (GenerateGUID(Services.Http));

	Library.Tabs[Config.Title] = { Open = function() 
		Animate.Open(Window, Settings.Theme.Transparency, UDim2.fromOffset(345, 418), false, true);
	end,}  

	Library.Tabs[Config.Title].Open()
	Animate.Drag(Window);

	--// Animations 

	function Animations:SetTab(Name)
		TabName.Text = Name
		Current = Name

		for Index, Main in next, Tabs:GetChildren() do
			if Main:IsA("CanvasGroup") then
				local Opened, SameName = Main.Value, (Main.Name == Name);
				local Scroll = Main.ScrollingFrame
				local Padding = Scroll.UIPadding

				if SameName and not Opened.Value then
					Opened.Value = true
					Main.Visible = true

					Tween(Main, .3, { GroupTransparency = 0 });
					Tween(Padding, .3, { PaddingTop = UDim.new(0, 8) });

				elseif not SameName and Opened.Value then
					Previous = Main.Name
					Opened.Value = false

					Tween(Main, .15, { GroupTransparency = 1 });
					Tween(Padding, .15, { PaddingTop = UDim.new(0, 18) });	

					Delay(.2, function()
						Main.Visible = false
					end)
				end
			end
		end
	end

	function Animations:Component(Button, Custom)	
		local Size = Button.Size 

		Connect(Button.InputBegan, function() 
			if Custom then
				Tween(Button, .25, { Transparency = 0, Size = UDimMultiply(Size, 1.1) });
			else
				Tween(Button, .25, { BackgroundColor3 = Color(Settings.Theme.Component, 5), Size = UDimMultiply(Size, 1.015) });
			end
		end)

		Connect(Button.InputEnded, function() 
			if Custom then
				Tween(Button, .25, { Transparency = 1, Size = Size });
			else
				Tween(Button, .25, { BackgroundColor3 = Settings.Theme.Component, Size = Size });
			end
		end)
	end

	--// Components
	function Component:Set(Component, Title, Description)
		local Labels = (Component.Frame);
		local TLabel, DLabel = (Labels.Title), (Labels.Description);

		if Title then
			TLabel.Text = Title 
		else
			Destroy(TLabel);
		end

		if Description then
			DLabel.Text = Description 
		else
			Destroy(DLabel);
		end
	end

	function Component:GetTab(Name)
		return Tabs[Name].ScrollingFrame
	end

	function Component:AddTab(Config: { Title: string, Description: string, Tab: string})
		local Button = Clone(Components["Section"]);
		local Tab = Clone(Components["SectionExample"]);

		Connect(Button.MouseButton1Click, function() 
			Animations:SetTab(Config.Title)
		end)

		Animations:Component(Button)
		Component:Set(Button, Config.Title, Config.Description)
		MultiSet(Tab, { Parent = Tabs, Name = Config.Title });		
		MultiSet(Button, {
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	function Component:AddDropdown(Config: { Title: string, Description: string, Options: {}, Tab: Instance, Callback: any }) 
		local Dropdown = Clone(Components["Dropdown"]);
		local Background = Window.Background
		local Text = Dropdown.Holder.Main.Title;

		Connect(Dropdown.MouseButton1Click, function()
			local Example = Clone(Features.DropdownExample);
			local Buttons = Example.Actions;

			Tween(Background, .25, { BackgroundTransparency = 0.6 });

			Example.Parent = Window
			Animate.Open(Example, 0)

			for Index, Button in next, Buttons:GetChildren() do
				if Button:IsA("TextButton") then
					Animations:Component(Button, true)

					Connect(Button.MouseButton1Click, function()
						Tween(Background, .25, { BackgroundTransparency = 1 });
						Animate.Close(Example);

						Wait(.25);
						Destroy(Example);
					end)
				end
			end

			for Index, Option in next, Config.Options do
				local Button = Clone(Features.DropdownButtonExample);

				Animations:Component(Button);
				Component:Set(Button, Index);
				MultiSet(Button, { Parent = Example.ScrollingFrame, Visible = true });

				Connect(Button.MouseButton1Click, function() 
					Tween(Button, .25, { BackgroundColor3 = Settings.Theme.Component });
					Config.Callback(Option, Dropdown)

					Text.Text = Index

					for Index, Others in next, Example:GetChildren() do
						if Others:IsA("TextButton") and Others ~= Button then
							Others.BackgroundColor3 = Settings.Theme.Component
						end
					end

					Tween(Background, .25, { BackgroundTransparency = 1 });
					Animate.Close(Example);

					Wait(.25);
					Destroy(Example);
				end)
			end
		end)

		Component:Set(Dropdown, Config.Title, Config.Description)
		Animations:Component(Dropdown);

		MultiSet(Dropdown, {
			Name = Config.Title,
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	function Component:AddButton(Config: { Title: string, Description: string, Tab: string, Callback: any })
		local Button = Clone(Components["Button"]);

		Component:Set(Button, Config.Title, Config.Description)
		Animations:Component(Button)

		Connect(Button.MouseButton1Click, function() 
			Config.Callback(Button);
		end)

		MultiSet(Button, {
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	function Component:AddInput(Config: { Title: string, Description: string, Tab: string, Default: string, Callback: any })
		local Button = Clone(Components["Input"]);
		local Box = Button.Main.TextBox 

		Box.Text = (Config.Default) or Blank
		Component:Set(Button, Config.Title, Config.Description)
		Animations:Component(Button)

		Connect(Button.MouseButton1Click, function() 
			Box:CaptureFocus()
		end)

		Connect(Box.FocusLost, function() 
			Config.Callback(Box.Text)
			Box.PlaceholderText = Box.Text
		end)

		MultiSet(Button, {
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	function Component:AddSection(Config: { Title: string, Tab: string })
		local Section = Clone(Components["TabSection"]);

		Section.Title.Text = Config.Title
		MultiSet(Section, {
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	function Component:AddParagraph(Config: { Title: string, Description: string, Tab: string })
		local Paragraph = Clone(Components["Paragraph"]);

		Component:Set(Paragraph, Config.Title, Config.Description)

		MultiSet(Paragraph, {
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	function Component:AddKeybind(Config: { Title: string, Description: string, Tab: string, Callback: any })
		local Dropdown = Clone(Components["Keybind"]);
		local Bind = Dropdown.Holder.Main.Title;

		local Mouse = { Enum.UserInputType.MouseButton1, Enum.UserInputType.MouseButton2, Enum.UserInputType.MouseButton3 }; 
		local Types = { 
			["Mouse"] = "Enum.UserInputType.MouseButton", 
			["Key"] = "Enum.KeyCode." 
		}

		Animations:Component(Dropdown);
		Component:Set(Dropdown, Config.Title, Config.Description)

		Connect(Dropdown.MouseButton1Click, function()
			local Time = tick();
			local Detect, Finished

			MultiSet(Bind, { Text = "..." });
			Detect = Connect(Services.Input.InputBegan, function(Key, Focused) 
				local InputType = (Key.UserInputType);

				if not Finished and not Focused then
					Finished = (true)
					Config.Callback(Key)

					if table.find(Mouse, InputType) then
						MultiSet(Bind, {
							Text = tostring(InputType):gsub(Types.Mouse, "MB")
						})
					elseif InputType == Enum.UserInputType.Keyboard then
						MultiSet(Bind, {
							Text = tostring(Key.KeyCode):gsub(Types.Key, Blank)
						})
					end
				end 
			end)
		end)

		MultiSet(Dropdown, {
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	function Component:AddToggle(Config: { Title: string, Description: string, Tab: string, Default: boolean, Callback: any })
		local Toggle = Clone(Components["Toggle"]);

		local On = Toggle["Value"];
		local Main = Toggle["Main"];
		local Circle = Main["ToggleLabel"];

		local Set = function(Value)
			if Value then
				Tween(Main,   .2, { BackgroundColor3 = Settings.Theme.Highlight });
				Tween(Circle, .2, { ImageColor3 = Color3.fromRGB(255, 255, 255), Position = UDim2.new(1, -16, 0.5, 0) });
			else
				Tween(Main,   .2, { BackgroundColor3 = Color(Settings.Theme.Component, 10) });
				Tween(Circle, .2, { ImageColor3 = Color(Settings.Theme.Component, 15), Position = UDim2.new(0, 4, 0.5, 0) });
			end

			On.Value = Value
		end 

		Set(Config.Default);
		Animations:Component(Toggle);
		Component:Set(Toggle, Config.Title, Config.Description)

		Connect(Toggle.MouseButton1Click, function()
			local Value = not On.Value

			Set(Value)
			Config.Callback(Value)
		end)

		MultiSet(Toggle, {
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	function Component:AddSlider(Config: { Title: string, Description: string, Tab: string, MaxValue: number, AllowDecimals: boolean, DecimalAmount: number, Callback: any })
		local Slider = Clone(Components["Slider"]);

		local Main = Slider["Slider"];
		local Amount = Main["Main"].Input;
		local Slide = Main["Slide"];
		local Fire = Slide["Fire"];
		local Fill = Slide["Highlight"];
		local Circle = Fill["Circle"];

		local Active = false
		local Value = 0

		local SetNumber = function(Number)
			if Config.AllowDecimals then
				local Power = 10 ^ (Config.DecimalAmount or 2)
				Number = math.floor(Number * Power + 0.5) / Power
			else
				Number = math.round(Number)
			end

			return Number
		end

		local Update = function(Number)
			local Scale = (Mouse.X - Slide.AbsolutePosition.X) / Slide.AbsoluteSize.X			
			Scale = (Scale > 1 and 1) or (Scale < 0 and 0) or Scale

			if Number then
				Number = (Number > Config.MaxValue and Config.MaxValue) or (Number < 0 and 0) or Number
			end

			Value = SetNumber(Number or (Scale * Config.MaxValue))
			Amount.Text = Value
			Fill.Size = UDim2.fromScale((Number and Number / Config.MaxValue) or Scale, 1)
			Config.Callback(Value)
		end

		local Activate = function()
			Active = true

			repeat task.wait()
				Update()
			until not Active
		end

		Fill.Size = UDim2.fromScale(Value, 1);
		Animations:Component(Slider);
		Component:Set(Slider, Config.Title, Config.Description)

		Connect(Amount.FocusLost, function() 
			Update(tonumber(Amount.Text) or 0)
		end)

		Connect(Fire.MouseButton1Down, Activate)
		Connect(Services.Input.InputEnded, function(Input) 
			if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
				Active = false
			end
		end)

		MultiSet(Slider, {
			Name = Config.Title,
			Parent = Tabs[Config.Tab].ScrollingFrame,
			Visible = true,
		})
	end

	Animations:Component(Topbar.Back, true);
	Animations:Component(Topbar.Search, true);
	for Index, Button in next, Actions:GetChildren() do
		local Type = (Button.Name);

		if Button:IsA("TextButton") then			
			Animations:Component(Button, true); 

			Connect(Button.MouseButton1Click, function() 
				if Type == "Close" then
					Animate.Close(Window);
					Wait(.25);
					Window.Visible = (false);
				elseif Type == "Minimize" then
					Minimzied = not Minimzied

					if Minimzied then
						Tween(Window, .25, { Size = UDim2.fromOffset(345, 60) })
					else
						Tween(Window, .25, { Size = UDim2.fromOffset(345, 394) })
					end
				elseif Type == "Maximize" then
					Maximized = not Maximized

					if Maximized then
						Tween(Window, .15, { Size = UDim2.fromScale(1, 1), Position = UDim2.fromScale(0.5, 0.5) })
					else
						Tween(Window, .15, { Size = UDim2.fromOffset(345, 394), Position = UDim2.fromScale(0.5, 0.5) })
					end
				end
			end)
		end
	end

	Animations:SetTab("Home")
	Connect(Topbar.Back.MouseButton1Click, function() 
		Animations:SetTab(Previous or "Home")
		Previous = nil
	end)

	local SearchEnabled = true	
	local TweenTexts = function(Bool, Speed) 
		local Transparency = (Bool and 0) or 1
		local Speed = Speed or .1

		Tween(TabName, Speed, { TextTransparency = Transparency });
		Tween(WindowName, Speed, { TextTransparency = Transparency });
	end

	Connect(Changed(SearchBox, "Text"), function() 
		for Index, Button in next, Tabs[Current].ScrollingFrame:GetChildren() do
			if Button:FindFirstChild("Frame") then 
				local Title = Button.Frame.Title 
				Button.Visible = Lower(Title.Text):find(Lower(SearchBox.Text))
			end
		end
	end)

	Connect(SearchBox.FocusLost, function() 
		SearchEnabled = (true);
		SearchBox.Visible = (false);
		TweenTexts(true, .3);
	end)

	Connect(Topbar.Search.MouseButton1Click, function() 
		SearchEnabled = not SearchEnabled 

		SearchBox.Visible = (not SearchEnabled)
		TweenTexts(SearchEnabled)

		if (not SearchEnabled) then
			SearchBox:CaptureFocus();
		end
	end)

	return Component
end

function API:Notify(Config: { Title: string, Description: string, Duration: number, Type: string }) 
	Spawn(function() 
		local Info = TweenInfo.new(.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
		local SetShadow = function(Box, Boolean) 
			Tween(Box.Shadow, .8, { 
				Transparency = (Boolean and 0.8) or 1
			})
		end

		if Settings.Toggles.Notify then
			local Notification = Clone(Features.Notification);
			local Box = Notification.CanvasGroup 

			local Timer = Box["Timer"]
			local Interact = Box["Interact"]
			local None = (Enum.AutomaticSize.None)

			local Methods = {
				["warn"] = { icon = "rbxassetid://18797417802", color = Color3.fromRGB(246, 233, 107) },
				["info"] = { icon = "rbxassetid://18754976792", color = Color3.fromRGB(110, 158, 246)},
				["success"] = { icon = "rbxassetid://18797434345", color = Color3.fromRGB(126, 246, 108)},
				["error"] = { icon = "rbxassetid://18797440055", color = Color3.fromRGB(246, 109, 104)},
			}; local Information = (Methods[Lower(Config.Type or "info")] or Methods["info"])
			local Opposite = (Settings.Theme.Mode == "Dark" and "Light") or "Dark"

			Timer.BackgroundColor3 = (Information.color);
			Timer.Outline.Color = Color(Information.color, 25, Opposite);

			Notification.Parent = UI.Frame
			Animate.Set(Box, Config.Title, Config.Description);	
			MultiSet(Box, {
				AutomaticSize = (None);
				Size = UDim2.fromOffset(100, 10);
				Visible = (true);
				GroupTransparency = (1);
			})

			local Duration = (tonumber(Config.Duration) or 5);
			local Closed = (false);

			-- very sorry for the ugly code
			local Open, Close = function() 
				SetShadow(Box, true)
				Tween(Notification, .4, { Size = UDim2.fromOffset(199, 80) }); Wait(.1)
				Services.Tween:Create(Box, Info, {
					Size = UDim2.fromOffset(229, 80);
					GroupTransparency = (Settings.Theme.Transparency);
				}):Play(); Wait(.3);
				Box.AutomaticSize = Enum.AutomaticSize.Y 
			end, function() 
				if (not Closed) then
					Closed = (true)

					SetShadow(Box, false);
					Tween(Box, .3, { GroupTransparency = 1 }); Notification.AutomaticSize = (None)
					Tween(Notification, .35, { Size = UDim2.fromOffset(199, 0) });
					Tween(Notification.UIPadding, .3, { PaddingLeft = UDim.new(0, 600) }); Wait(.35)
					Destroy(Notification)
				end
			end

			Connect(Interact.MouseButton1Click, Close); Open();
			Tween(Timer, Duration, { Size = UDim2.fromOffset(0, 2) })
			Wait(Duration); Close()
		end
	end)
end

local Output = function(...) 
	if Settings.Toggles.Developer then
		warn(...);
	end
end

local Themes = {
	Names = {	
		["Topbar"] = function(Label)
			if Label:IsA("Frame") then
				Label.BackgroundColor3 = (Settings.Theme.Secondary);
			end
		end,

		["Actions"] = function(Label)
			if Label:IsA("Frame") then
				Label.BackgroundColor3 = (Settings.Theme.Actions);

				for Index, Button in next, Label:GetChildren() do
					if Button:IsA("TextButton") then
						Button.BackgroundColor3 = Color(Settings.Theme.Actions, 2)
					end
				end
			end
		end,

		["Main"] = function(Label)
			if Label:IsA("Frame") or Label:IsA("CanvasGroup") then
				if Label.Parent:FindFirstChild("Value") then
					local Toggle = Label.Parent.Value 
					local Circle = Label:FindFirstChild("ToggleLabel")

					if not Toggle.Value then
						Circle.ImageColor3 = Color(Settings.Theme.Component, 15)
						Label.BackgroundColor3 = Color(Settings.Theme.Component, 10);
					else 
						Label.BackgroundColor3 = (Settings.Theme.Highlight);
					end
				else
					Label.BackgroundColor3 = Color(Settings.Theme.Component, 10);
				end
			end
		end,

		["Frame"] = function(Label) 
			if Label:IsA("Frame") and Label:FindFirstChild("Title") then
				local Component = Label.Parent 
				local Mode = Settings.Theme.Mode
				if Component.Name == "Paragraph" then
					Component.BackgroundColor3 = Color(Settings.Theme.Component, 2, "Light")
				else
					Component.BackgroundColor3 = (Settings.Theme.Component)
				end
			end
		end,

		["Slide"] = function(Label) 
			if Label:IsA("Frame") then
				Label.BackgroundColor3 = Color(Settings.Theme.Component, 10)
			end
		end,

		["Point"] = function(Label) 
			if Label:IsA("Frame") then
				Label.BackgroundColor3 = Color(Settings.Theme.Component, 15)
			end
		end,

		["Press"] = function(Label) 
			if Label:IsA("Frame") then
				Label.BackgroundColor3 = Color(Settings.Theme.Secondary, 5)
			end
		end,

		["Back"] = function(Label) 
			if Label:IsA("TextButton") then
				Label.BackgroundColor3 = Color(Settings.Theme.Secondary, 5)
			end
		end,

		["Search"] = function(Label) 
			if Label:IsA("TextButton") then
				Label.BackgroundColor3 = Color(Settings.Theme.Secondary, 5)
			elseif Label:IsA("Frame") then 
				Label.BackgroundColor3 = (Settings.Theme.Secondary)
			end
		end,

		["SearchBox"] = function(Label) 
			if Label:IsA("TextBox") then
				Label.PlaceholderColor3 = (Settings.Theme.Description);
				Label.TextColor3 = (Settings.Theme.Title);
			end
		end,

		--// Tables
		["Title"]		    = { "TextLabel", "Title", "TextColor3" };
		["Description"]    = { "TextLabel", "Description", "TextColor3" };
		["Line"] 	    	    = { "Frame", "Highlight", "BackgroundColor3" };
		["AutofillButton"] = { "TextButton", "Secondary", "BackgroundColor3" };
		["UIStroke"] 	    = { "UIStroke", "Outline", "Color" };
		["Shadow"] 	    = { "UIStroke", "Shadow", "Color" };
		["Highlight"] 	    = { "Frame", "Highlight", "BackgroundColor3" };
		["Circle"] 	    = { "Frame", "Highlight", "BackgroundColor3" };
		["Notification"]   = { "CanvasGroup", "Primary", "BackgroundColor3", true };
		["DropdownExample"]= { "CanvasGroup", "Primary", "BackgroundColor3" };

	},

	Classes = {
		["TextBox"] = function(Label) 
			if Label.Name ~= "Recommend" then
				Label.TextColor3 = (Settings.Theme.Title);
			else 
				Label.TextColor3 = (Settings.Theme.Description);
			end
		end,

		["CanvasGroup"] = function(Label) 
			if Label.Parent == UI then
				Label.BackgroundColor3 = (Settings.Theme.Primary);
				Label.GroupTransparency = (Settings.Theme.Transparency)
			end
		end,

		["ImageLabel"] = function(Label) 
			if Label.Image ~= "rbxassetid://6644618143" then
				Label.ImageColor3 = (Settings.Theme.Icon);
			end
		end,

		["ScrollingFrame"] = function(Label) 
			Label.ScrollBarImageColor3 = (Settings.Theme.ScrollBar);
		end,
	},
}

local DefaultThemes = {
	["Dark"] 	  = {Mode = "Dark"; Transparency = 0; Primary = Color3.fromRGB(25, 25, 25), Secondary = Color3.fromRGB(30, 30, 30), Actions = Color3.fromRGB(30, 33, 52), Component = Color3.fromRGB(30, 30, 30), Highlight = Color3.fromRGB(86, 159, 204), ScrollBar = Color3.fromRGB(39, 39, 39), Title = Color3.fromRGB(255, 255, 255), Description = Color3.fromRGB(155, 155, 155), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(52, 52, 52), Icon = Color3.fromRGB(255, 255, 255)},
	["Dracula"]   = {Mode = "Dark"; Transparency = 0; Primary = Color3.fromRGB(40, 42, 54), Secondary = Color3.fromRGB(46, 48, 62), Actions = Color3.fromRGB(58, 61, 77), Component = Color3.fromRGB(43, 45, 59), Highlight = Color3.fromRGB(98, 114, 164), ScrollBar = Color3.fromRGB(23, 24, 31), Title = Color3.fromRGB(255, 255, 255), Description = Color3.fromRGB(155, 155, 155), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(51, 54, 68), Icon = Color3.fromRGB(255, 255, 255)},
	["Light"] 	  = {Mode = "Light"; Transparency = 0; Primary = Color3.fromRGB(255, 255, 255), Secondary = Color3.fromRGB(245, 245, 245), Actions = Color3.fromRGB(225, 232, 238), Component = Color3.fromRGB(245, 245, 245), Highlight = Color3.fromRGB(153, 155, 255), ScrollBar = Color3.fromRGB(150, 150, 150), Title = Color3.fromRGB(40, 40, 40), Description = Color3.fromRGB(155, 155, 155), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(230, 230, 230), Icon = Color3.fromRGB(40, 40, 40)},
	["Nord"] 	  = {Mode = "Dark", Transparency = 0, Primary = Color3.fromRGB(41, 47, 56), Secondary = Color3.fromRGB(46, 52, 64), Actions = Color3.fromRGB(107, 135, 156), Component = Color3.fromRGB(46, 52, 64), Highlight = Color3.fromRGB(136, 192, 208), ScrollBar = Color3.fromRGB(51, 59, 70), Title = Color3.fromRGB(255, 255, 255), Description = Color3.fromRGB(200, 200, 200), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(59, 66, 82), Icon = Color3.fromRGB(255, 255, 255)},
	["Void"] 	  = {Mode = "Dark"; Transparency = 0; Primary = Color3.fromRGB(15, 15, 15), Secondary = Color3.fromRGB(20, 20, 20), Actions = Color3.fromRGB(12, 16, 22), Component = Color3.fromRGB(20, 20, 20), Highlight = Color3.fromRGB(84, 132, 164), ScrollBar = Color3.fromRGB(30, 30, 30), Title = Color3.fromRGB(255, 255, 255), Description = Color3.fromRGB(155, 155, 155), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(25, 25, 25), Icon = Color3.fromRGB(255, 255, 255)},
	["Discord"] = {Mode = "Dark", Transparency = 0, Primary = Color3.fromRGB(40, 43, 48), Secondary = Color3.fromRGB(54, 57, 62), Actions = Color3.fromRGB(62, 64, 68), Component = Color3.fromRGB(47, 50, 55), Highlight = Color3.fromRGB(114, 137, 218), ScrollBar = Color3.fromRGB(47, 51, 57), Title = Color3.fromRGB(255, 255, 255), Description = Color3.fromRGB(155, 155, 155), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(66, 69, 73), Icon = Color3.fromRGB(255, 255, 255)},

	["RC7"] 	  = {Mode = "Dark", Transparency = 0, Primary = Color3.fromRGB(11, 47, 80), Secondary = Color3.fromRGB(20, 58, 96), Actions = Color3.fromRGB(20, 60, 94), Component = Color3.fromRGB(19, 54, 90), Highlight = Color3.fromRGB(89, 121, 180), ScrollBar = Color3.fromRGB(10, 45, 75), Title = Color3.fromRGB(255, 255, 255), Description = Color3.fromRGB(155, 155, 155), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(33, 72, 105), Icon = Color3.fromRGB(255, 255, 255)},
	["RC7 Red"]   = {Mode = "Dark", Transparency = 0, Primary = Color3.fromRGB(70, 36, 33), Secondary = Color3.fromRGB(66, 34, 31), Actions = Color3.fromRGB(89, 42, 42), Component = Color3.fromRGB(66, 34, 31), Highlight = Color3.fromRGB(255, 88, 88), ScrollBar = Color3.fromRGB(77, 32, 29), Title = Color3.fromRGB(255, 255, 255), Description = Color3.fromRGB(175, 175, 175), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(89, 46, 42), Icon = Color3.fromRGB(255, 255, 255)},
	["c00l 1337"] = {Mode = "Dark", Transparency = 0, Primary = Color3.fromRGB(0, 0, 0), Secondary = Color3.fromRGB(0, 0, 0), Actions = Color3.fromRGB(255, 0, 0), Component = Color3.fromRGB(10, 10, 10), Highlight = Color3.fromRGB(255, 0, 0), ScrollBar = Color3.fromRGB(20, 20, 20), Title = Color3.fromRGB(255, 255, 255), Description = Color3.fromRGB(155, 155, 155), Shadow = Color3.fromRGB(0, 0, 0), Outline = Color3.fromRGB(255, 0, 0), Icon = Color3.fromRGB(255, 255, 255)},
}

local SetTheme = function(Table)
	Settings.Theme = Table or Settings.Theme
	CommandBar.BackgroundColor3 = Settings.Theme.Primary

	for Index, Descendant in next, UI:GetDescendants() do
		xpcall(function() 
			local Name = Themes.Names[Descendant.Name]
			local Class = Themes.Classes[Descendant.ClassName]

			if Name then
				if typeof(Name) == "table" then
					local ClassName, NewColor, NewProperty, SetTransparency = unpack(Name);

					if (ClassName == "any" or ClassName == Descendant.ClassName) then
						Descendant[NewProperty] = Settings.Theme[NewColor]
					end

					if SetTransparency and Descendant:IsA("CanvasGroup") then
						Descendant.GroupTransparency = (Settings.Theme.Transparency);
					end

				elseif typeof(Name) == "function" then
					Name(Descendant);
				end
			elseif Class then
				Class(Descendant);
			end
		end, function(Result) 
			Output("An error occured trying to load", Descendant, " error:", Result)
		end)
	end
end

-- :: IMPORTANT :: -- 

local EncodedSettings = function() 
	local NewSettings = { Theme = {} }

	for Index, Theme in next, Settings.Theme do 
		if typeof(Theme) == "Color3" then
			NewSettings.Theme[Index] = tostring(Theme)
		else 
			NewSettings.Theme[Index] = tostring(Theme)
		end
	end

	for Index, Theme in next, Settings do 
		if Index ~= "Theme" then
			NewSettings[Index] = Theme
		end
	end

	return JSONEncode(Services.Http, NewSettings);
end

local GetSavedSettings = function() 
	local Themed = JSONDecode(Services.Http, (Check("File") and readfile("Cmd/Settings.json")) or EncodedSettings()) 
	local Theming = { Theme = {} }

	for Index, Theme in next, Themed.Theme do 
		if typeof(Theme) == "string" and Find(Theme, ",") then
			local Clr = Color3.new(Unpack(Split(Theme, ",")));
			Theming.Theme[Index] = Color3.fromRGB(Clr.R * 255, Clr.G * 255, Clr.B * 255)
		elseif Index == "Transparency" then
			Theming.Theme[Index] = tonumber(Theme);
		elseif Index == "Mode" then
			Theming.Theme["Mode"] = tostring(Theme)
		end
	end

	for Index, Theme in next, Themed do 
		if Index ~= "Theme" then
			Theming[Index] = Theme
		end
	end

	return Theming
end

local SaveSettings = function()
	if Check("File") then
		writefile("Cmd/Settings.json", EncodedSettings())
	end
end

local UpdateSettings = function(Data)
	if Check("File") then
		writefile("Cmd/Settings.json", (Data and JSONEncode(Services.Http, Data)) or EncodedSettings());
	end
end

local SetSetting = function(Table, Config, Data)
	local S = (Table and Settings[Table]) or Settings
	S[Config] = Data 
	UpdateSettings()
end

-- :: LIBRARY[CMD] :: --
local Command = {}
local Commands = {}

Command.Add = function(Information)
	local Aliases = Information.Aliases;
	local Description = Information.Description;
	local Arguments = Information.Arguments;
	local Plugin = Information.Plugin;
	local Task = Information.Task;

	for Index, Value in next, Aliases do
		Index = Lower(Value)
	end

	Commands[Lower(Aliases[1])] = { Aliases, Description, Arguments, Plugin, Task } 
end

Command.Find = function(Input)
	for Index, Table in next, Commands do
		local Aliases = Table[1]
		local Found = FindTable(Aliases, Input)

		if Found then
			return Table
		end
	end
end

Command.Run = function(IgnoreNotifications, Name, Callbacks)
	Spawn(function()
		local Table = Command.Find(Name)

		if Table and Name ~= Blank then
			local Callback = Table[5]

			xpcall(function() 
				local Title, Description, Duration, Type = Callback(Unpack(Callbacks))
				if Title and Description and not IgnoreNotifications then 
					API:Notify({
						Title = Title,
						Description = Description,
						Type = "Info",
						Duration = Duration or 5,
					})
				end
			end, function(Result) 
				Output(Format("[COMMAND ERROR] : Error occured trying to run the command - %s\nERROR: %s", Name, Result))
			end)

		elseif Name ~= Blank then
			API:Notify({
				Title = "Command not found!", 
				Description = Format("<b>%s</b> is not a valid command", Name),
				Type = "Error",
				Duration = 5,
			})
		end
	end)
end

Command.Parse = function(IgnoreNotifications, Input)
	local Name, ArgsString = GSub(Input, Settings.Prefix, Blank):match("^%s*([^%s]+)%s*(.*)$")

	if Name then
		local Arguments = {}
		for arg in ArgsString:gmatch("%s*([^"..Settings.Seperator .."]+)") do
			Insert(Arguments, arg)
		end

		FullArgs = Arguments
		Command.Run(IgnoreNotifications, Lower(Name), Arguments)
	end
end

Command.Whitelist = function(Player)
	Admins[Player.UserId] = true
	Connect(Player.Chatted, function(Message)
		if Find(Message, Settings.ChatPrefix) then 
			Command.Parse(false, Split(Message, Settings.ChatPrefix)[2]);
		end
	end)
end

Command.RemoveWhitelist = function(Player)
	Admins[Player.UserId] = false
end

-- :: LIBRARY[AUTOFILL] :: --
Fill.Add = function(Table)	
	local Aliases, Description, Arguments, Plugin, Callback = Unpack(Table)
	local Button = Clone(Autofill.Example)
	local Labels = Button.Frame 

	local Arg = Concat(Aliases, " / ")

	Labels.Title.Text = Arg 
	Labels.Description.Text = Description

	MultiSet(Button, {
		Parent = Autofill,
		Visible = true,
		Name = "AutofillButton",
	})
end

Fill.Recommend = function(Input)
	if (not Settings.Toggles.Recommendation) or (#Input == 0) then 
		Recommend.Text = Blank; return
	end

	local Lowered = Lower(Split(Input, ' ')[1])
	local Found = false

	--// Command Recommendation
	if #Split(Input, ' ') == 1 then
		for Index, Table in Commands do
			for Index, Name in Table[1] do
				if (Find(Sub(Name, 1, #Lowered), Lower(Lowered)) or Name == Lowered) and not Found then
					Press.Title.Text = "Tab"
					Recommend.Text = GSub(Name, Lowered, Split(Input, " ")[1])
					Found = true
				end
			end
		end
	end

	if #Split(Input, " ") > 1 and UI.Parent then
		local Command = Command.Find(Lowered)
		if Command then
			local Arguments = Command[3]
			local New = Split(Input, " ")

			if #Arguments > 0 then
				if Arguments[#New - 1] and Arguments[#New - 1].Type == "Player" then
					local PlayerFound = false
					local Player = New[#New]

					--// Display Name Recommendation

					for Index, Plr in next, Services.Players:GetPlayers() do
						if Find(Sub(Lower(Plr.DisplayName), 1, #Player), Lower(Player)) then
							local Name = Format(" %s", GSub(Lower(Plr.DisplayName), Lower(Player), Player))
							Recommend.Text = Sub(Input, 1, #Input - #Player - 1) .. Name
							Found = true
							PlayerFound = true
						end
					end

					--// Username Recommendation


					if not PlayerFound then
						for Index, Plr in next, Services.Players:GetPlayers() do
							if Find(Sub(Lower(Plr.Name), 1, #Player), Lower(Player)) then
								local Name = Format(" %s", GSub(Lower(Plr.Name), Lower(Player), Player))
								Recommend.Text = Sub(Input, 1, #Input - #Player - 1) .. Name
								Found = true
								PlayerFound = true
							end
						end
					end

					--// Player Argument Recommendation

					if not PlayerFound then
						local GetPlayerArguments = { "all", "random", "others", "seated", "stood", "me", "closest", "farthest", "enemies", "dead", "alive", "friends", "nonfriends"}
						for Index, Arg in next, GetPlayerArguments do
							if Find(Sub(Arg, 1, #Player), Lower(Player)) then
								local Name = Format(" %s", GSub(Lower(Arg), Lower(Player), Player))
								Recommend.Text = Sub(Input, 1, #Input - #Player - 1) .. Name
								Found = true
								PlayerFound = true
							end
						end 
					end
				end
			end
		end
	end

	if not Found then
		local Amount = #Input
		local Spaces = Split(Input, " ")
		local Arguments = Split(Input, Settings.Seperator)

		local Cmd, Args = false, false
		local Check = (Sub(Input, Amount - 1) == Format("%s ", Settings.Seperator))

		if #Spaces >= 1 then
			if Check or (#Spaces == 2 and Sub(Input, Amount) == " ") then
				for Index, Table in Commands do
					for Index, Name in Table[1] do
						if Lower(Name) == Lower(Spaces[1]) then
							Cmd = Name
							Args = Table[3]

							break
						end
					end
				end

				if Cmd then
					local Amount = (#Spaces == 2 and 1) or (#Arguments)
					local Argument = Args[Amount]

					if Argument then
						Recommend.Text = Format("%s%s", Input, Lower(Argument.Name))
						Press.Title.Text = "Enter"
						Found = true
					end
				end
			end
		end
	end

	if not Found then
		Press.Title.Text = "Enter"
		Recommend.Text = Blank
	end
end


Fill.Search = function(Input)
	Spawn(function()
		local Lowered = GSub(Lower(Split(Input, " ")[1]), Settings.Prefix, Blank)
		local FoundFirst = false
		local Amount = 0
		local Found = false

		if #Split(Input, ' ') == 1 then
			for Index, Table in Commands do
				for Index, Name in Table[1] do
					if Find(Sub(Name, 1, #Lowered), Lower(Lowered)) or Name == Lowered then
						Press.Title.Text = "Tab"
						Recommend.Text = GSub(Name, Lowered, Split(Input, " ")[1])
						Found = true
					end
				end
			end
		end

		for Index, Frame in next, Autofill:GetChildren() do
			if Frame.Name == "AutofillButton" then
				if (not Settings.Toggles.FillCap) or (Amount < 4) then
					local Commands = Frame.Frame.Title
					local FrameFound = false

					for Index, Name in Split(Commands.Text, " / ") do
						if (Find(Sub(Name, 1, #Lowered), Lower(Lowered)) or Name == Lowered) and not FrameFound then
							FrameFound = true 
							Amount += 1

							if not FoundFirst then
								Frame.BackgroundColor3 = (Settings.Theme.Component);
								FoundFirst = true
							else
								Frame.BackgroundColor3 = (Settings.Theme.Primary);
							end
						end
					end

					Frame.Visible = FrameFound
				else
					Frame.Visible = false
				end
			end
		end

		-- Resizing Command Bar
		local Sizes = {
			[1] = { Size = UDim2.new(1, -4, 0, 67) };
			[2] = { Size = UDim2.new(1, -4, 0, 125) };
			[3] = { Size = UDim2.new(1, -4, 0, 183) };
			[4] = { Size = UDim2.new(1, -4, 0, 240) };
		}

		local Size = Sizes[Amount] or Sizes[4]
		Tween(Autofill, .25, { Size = Size.Size });
		Tween(CommandBar, .25, { Position = Size.Position });
	end)	
end

--// :: FEATURE

--// Waypoints 

function Feature:AddWaypoint(Name, CFrame) 
	CFrame = tostring(CFrame);

	if Name and CFrame then 
		Settings.Waypoints[Name] = CFrame 
		SaveSettings()

		API:Notify({
			Title = "Waypoints",
			Description = "Added waypoint successfully!",
			Type = "Success",

			Duration = (10),
		})
	else 
		API:Notify({
			Title = "Waypoints",
			Description = "Error adding waypoint, is one of the arguments missing?",
			Type = "Error",

			Duration = (15),
		})
	end
end

--// Events 
function Feature:AddEvent(Event, Command) 
	local info = Settings.Events[Event]

	if info and not info[Command] then 
		info[Command] = Command 
		SaveSettings()

		API:Notify({
			Title = "Events",
			Description = "Added event successfully",
			Type = "Success",

			Duration = (10),
		})
	else 
		API:Notify({
			Title = "Events",
			Description = "Error adding an event, event doesn't exist or command already added in the event.",
			Type = "Error",

			Duration = (15),
		})
	end
end

function Feature:ConnectEvent(Event, Connection, UseHumanoid, Check) 
	local RunEvent = function(Event) 
		Foreach(Settings.Events[Event] or (warn(Event) and {}), function(_, command) 
			Command.Parse(false, command);
		end) 
	end

	if (Event == "AutoExecute") then 
		RunEvent(Event)
	elseif Event == "PlayerRemoved" then 
		Connect(Services.Players.PlayerRemoving, function(Plr) 
			if Plr == LocalPlayer then 
				RunEvent("PlayerRemoved");
			end
		end)
	elseif UseHumanoid and typeof(Event) == "string" then 
		local CCharacter = Character 
		local CHumanoid = CCharacter:FindFirstChild("Humanoid")

		local CDetect = function(CHumanoid) 
			if Event == "Damaged" then 
				Connect(Changed(CHumanoid, "Health"), function() 
					if not Check or (Check and Check(CHumanoid)) then 
						RunEvent("Damaged");
					end
				end)
			else 
				Connect(CHumanoid[Event], function() 
					if not Check or (Check and Check(CHumanoid)) then 
						RunEvent(Event);
					end
				end)
			end
		end

		local Char = Character or (LocalPlayer.Character or CWait(LocalPlayer.CharacterAdded)) -- so doesnt error if character doesnt exist
		CDetect(CHumanoid or Char:WaitForChild("Humanoid"));
		Connect(LocalPlayer.CharacterAdded, function(NewCharacter) 
			CCharacter = NewCharacter
			CDetect(CCharacter:WaitForChild("Humanoid"));
		end)
	else 
		Connect(Connection, function() 
			RunEvent(Event);
		end)
	end
end

-- :: COMMANDS :: -- 
Command.Add({
	Aliases = { "settings" },
	Description = "Opens the settings tab",
	Arguments = {},
	Task = function()
		local Tab = Library.Tabs.Settings

		if Tab then
			Tab.Open()
		else 
			local Keybinds = {}
			local Window = Library:CreateWindow({
				Title = "Settings",
			})

			Window:AddTab({
				Title = "About",
				Description = "List of credits & information about Cmd",
				Tab = "Home"
			})

			Window:AddTab({
				Title = "Prefixes",
				Description = "Change the prefixes of Cmd",
				Tab = "Home"
			})

			Window:AddTab({
				Title = "Toggles",
				Description = "Toggle between different features",
				Tab = "Home"
			})

			Window:AddTab({
				Title = "Theme",
				Description = "Customize the look of Cmd",
				Tab = "Home"
			})

			Window:AddTab({
				Title = "Waypoints",
				Description = "Set up buttons for places to teleport to",
				Tab = "Home"
			})

			Window:AddTab({
				Title = "Keybinds",
				Description = "Set keybinds for running commands",
				Tab = "Home"
			})

			Window:AddTab({
				Title = "Events",
				Description = "Set commands that run during specific events",
				Tab = "Home"
			})


			--// About 
			Window:AddSection({ Title = "Prefixes", Tab = "About"})

			Window:AddParagraph({
				Title = "Prefix",
				Description = Format("Current prefix is '%s'", Settings.Prefix);
				Tab = "About",
			})

			Window:AddParagraph({
				Title = "Chat Prefix",
				Description = Format("Current chat prefix is '%s'", Settings.ChatPrefix);
				Tab = "About",
			})

			Window:AddParagraph({
				Title = "Seperator",
				Description = Format("Current argument seperator is '%s'", Settings.Seperator);
				Tab = "About",
			})

			Window:AddSection({ Title = "Cmd", Tab = "About"})

			Window:AddParagraph({
				Title = "Version",
				Description = Format("Version %s", Settings.Version);
				Tab = "About",
			})

			Window:AddParagraph({
				Title = "Invite",
				Description = "https://discord.gg/j75xENkG";
				Tab = "About",
			})
			--// Settings 

			Window:AddInput({
				Title = "Prefix",
				Description = "Prefix for the Command Bar";
				Tab = "Prefixes",
				Default = Settings.Prefix,
				Callback = function(Key) 
					if #Key == 1 then
						Settings.Prefix = Key 
						SaveSettings()
					else 
						API:Notify({
							Title = "Couldn't set prefix",
							Description = "Prefix character amount is bigger or smaller than 1",
							Type = "Error",
							Duration = 10,
						})
					end
				end,
			})

			Window:AddInput({
				Title = "Chat Prefix",
				Description = "Prefix for using commands in chat";
				Tab = "Prefixes",
				Default = Settings.ChatPrefix,
				Callback = function(Key) 
					if #Key == 1 then
						Settings.ChatPrefix = Key
						SaveSettings()
					else 
						API:Notify({
							Title = "Couldn't set prefix",
							Description = "Prefix character amount is bigger or smaller than 1",
							Type = "Error",
							Duration = 10,
						})
					end
				end,
			})

			--// Toggles
			Window:AddSection({ Title = "Command Bar", Tab = "Toggles"})

			Window:AddToggle({
				Title = "Recommendation", 
				Description = "Toggle if Cmd should recommend commands",
				Tab = "Toggles",
				Default = Settings.Toggles.Recommendation,
				Callback = function(Toggle)
					Settings.Toggles.Recommendation = Toggle
					SaveSettings()
				end,
			})

			Window:AddSection({ Title = "Autofill", Tab = "Toggles"})

			Window:AddToggle({
				Title = "Autofill Cap", 
				Description = "If enabled autofill will only show 4 commands that match",
				Tab = "Toggles",
				Default = Settings.Toggles.FillCap,
				Callback = function(Toggle)
					Settings.Toggles.FillCap = Toggle
					SaveSettings()
				end,
			})

			Window:AddSection({ Title = "Others", Tab = "Toggles"})

			Window:AddToggle({
				Title = "Developer Mode", 
				Description = "Toggle to get more information about what's going on in console!",
				Tab = "Toggles",
				Default = Settings.Toggles.Developer,
				Callback = function(Toggle)
					Settings.Toggles.Developer = Toggle
					SaveSettings()
				end,
			})

			Window:AddToggle({
				Title = "Staff Notifier", 
				Description = "Notifies all staff in the server and if a staff has joined your server",
				Tab = "Toggles",
				Default = Settings.Toggles.StaffNotifier,
				Callback = function(Toggle)
					Settings.Toggles.StaffNotifier = Toggle
					SaveSettings()
				end,
			})

			Window:AddToggle({
				Title = "Ignore Seated for Fling", 
				Description = "Useful to only turn on if someone is in a car",
				Tab = "Toggles",
				Default = Settings.Toggles.IngoreSeated,
				Callback = function(Toggle)
					Settings.Toggles.IngoreSeated = Toggle
					SaveSettings()
				end,
			})

			Window:AddToggle({
				Title = "Internal UI", 
				Description = "If enabled when pressing LeftAlt will show an Internal UI",
				Tab = "Toggles",
				Default = Settings.Toggles.InternalUI,
				Callback = function(Toggle)
					Settings.Toggles.InternalUI = Toggle
					SaveSettings()
				end,
			})

			Window:AddToggle({
				Title = "Notifications Enabled", 
				Description = "Toggle between if notifications get sent",
				Tab = "Toggles",
				Default = Settings.Toggles.Notify,
				Callback = function(Toggle)
					Settings.Toggles.Notify = Toggle
					SaveSettings()
				end,
			})

			Window:AddToggle({
				Title = "Popups Enabled", 
				Description = "If disabled will just accept popups automatically",
				Tab = "Toggles",
				Default = Settings.Toggles.Popups,
				Callback = function(Toggle)
					Settings.Toggles.Popups = Toggle
					SaveSettings()
				end,
			})

			--// Themes
			Window:AddSection({ Title = "Colors", Tab = "Theme" })

			Window:AddTab({
				Title = "Create Theme",
				Description = "Create your own custom theme",
				Tab = "Theme",
			})

			Window:AddDropdown({
				Title = "Default Themes",
				Tab = "Theme",
				Options = DefaultThemes,
				Callback = function(Theme) 
					Theme.Transparency = (Settings.Theme.Transparency);

					SetTheme(Theme)
					SaveSettings()
				end,
			})

			Window:AddSection({ Title = "Others", Tab = "Theme" })

			Window:AddSlider({
				Title = "UI Transparency",
				Tab = "Theme",
				MaxValue = .8,
				AllowDecimals = true,
				DecimalAmount = 2,
				Callback = function(Amount) 
					Settings.Theme.Transparency = Amount
					SetTheme()
				end,
			})

			Window:AddDropdown({
				Title = "UI Mode",
				Description = "IMPORTANT: Set this up correctly so it doesn't mess up with the UI hover effects",
				Tab = "Theme",
				Options = {
					["Light Mode"] = "Light",
					["Dark Mode"] = "Dark",
				},
				Callback = function(Type) 
					Settings.Theme.Mode = Type
					SetTheme()
				end,
			})

			Window:AddButton({
				Title = "Save Theme",
				Description = "Saves the theme you've created",
				Tab = "Theme",
				Callback = function() 
					SaveSettings();
					API:Notify({
						Title = "Success",
						Description = "Successfully saved your theme",
						Type = "Sucess",
						Duration = 5,
					})
				end,
			})

			--// Keybinds

			Window:AddTab({
				Title = "Create Keybind",
				Description = "Create a Keybind to use",
				Tab = "Keybinds"
			})

			Window:AddTab({
				Title = "Current Keybinds",
				Description = "List of active Keybinds",
				Tab = "Keybinds"
			})

			-- : Create Keybind
			local Keybind = { Begin = nil, End = nil, Key = nil }
			local CreateKeybind = function(Keybind)
				local Key, Begin, End = Keybind.Key,
				Keybind.Begin, Keybind.End

				Window:AddButton({
					Title = GSub(tostring(Key.KeyCode), "Enum.KeyCode.", Blank);
					Description = "Click this to remove the Keybind",
					Tab = "Current Keybinds",
					Callback = function(Button) 
						Keybinds[Key] = (nil);
						Destroy(Button);
					end,
				})
			end
			Window:AddSection({ Title = "Create", Tab = "Create Keybind"})

			Window:AddButton({
				Title = "Create Keybind",
				Description = "Create the Keybind!";
				Tab = "Create Keybind",
				Callback = function() 
					local Key, Begin, End = Keybind.Key ,
					Keybind.Begin, Keybind.End

					if not Keybinds[Key] and Begin and End and Key then
						Keybinds[Keybind.Key] = { Begin = Begin, End = End, Key = Key, Active = false };
						CreateKeybind(Keybinds[Keybind.Key])

						API:Notify({
							Title = "Keybind",
							Description = "Created Keybind successfully!",
							Duration = 15,
							Type = "Success",
						})
					else
						API:Notify({
							Title = "Keybind",
							Description = "Unable to make Keybind since a Keybind with the same key exists or one of the arguments is missing",
							Duration = 15,
							Type = "Error",
						})
					end
				end,
			})

			Window:AddSection({ Title = "Settings", Tab = "Create Keybind"})

			Window:AddKeybind({
				Title = "Keybind Keybind",
				Description = "The keybind for the Keybind";
				Tab = "Create Keybind",
				Callback = function(Key) 
					Keybind.Key = Key
				end,
			})

			Window:AddInput({
				Title = "Keybind Begin Command",
				Description = "The command to run when you want the Keybind to begin";
				Tab = "Create Keybind",
				Callback = function(Cmd) 
					Keybind.Begin = Cmd
				end,
			})

			Window:AddInput({
				Title = "Keybind End Command",
				Description = "The command to run when you want to END the Keybind";
				Tab = "Create Keybind",
				Callback = function(Cmd) 
					Keybind.End = Cmd
				end,
			})

			Connect(Services.Input.InputBegan, function(Key)
				local Keybind = Keybinds[Key]

				if Keybind then					
					if Keybind.Active then
						Command.Parse(true, Keybinds[Key].End)
					else 
						Command.Parse(true, Keybinds[Key].Begin)
					end

					Keybind.Active = not Keybind.Active
				end
			end)

			--// Waypoints

			local AddWaypoint = function(Name, Position) 
				Window:AddDropdown({
					Title = Name,
					Description = "Pick between the two options!",
					Options = {
						["Teleport to"] = "TP",
						["Remove Waypoint"] = "Remove",
					},
					Tab = "Waypoints",
					Callback = function(Method, Button) 
						local Waypoint = Settings.Waypoints[Name]

						if (Method == "TP") then
							Root.CFrame = Position
						else 
							Settings.Waypoints[Name] = (nil);
							Destroy(Button);
							SaveSettings();
						end
					end,
				})
			end

			Window:AddSection({ Title = "Create", Tab = "Waypoints" })
			Window:AddInput({
				Title = "Make Waypoint (NAME)",
				Tab = "Waypoints",
				Callback = function(Name) 
					local Position = (Root.CFrame)

					Feature:AddWaypoint(Name, Position)
					AddWaypoint(Name, Position)
				end,
			})

			Window:AddSection({ Title = "Created Waypoints", Tab = "Waypoints" })

			for WaypointName, SavedPosition in next, Settings.Waypoints do 
				AddWaypoint(WaypointName, CFrame.new(Unpack(Split(SavedPosition, ","))))
			end

			--// Events 

			Window:AddTab({
				Title = "Create Event",
				Description = "Create a event to fire",
				Tab = "Events"
			})

			Window:AddTab({
				Title = "Current Events",
				Description = "List of active events",
				Tab = "Events"
			})

			-- : Create event
			local SelectedEvent = ("Unselected");
			local EventCommand

			for EventName, SavedEvent in next, Settings.Events do 
				for _, SavedCommand in next, SavedEvent do 
					Window:AddButton({
						Title = Format("Event for %s", EventName);
						Description = Format("Click to delete the event\nCommand: %s", SavedCommand),
						Tab = "Current Events",
						Callback = function(Button) 
							Settings.Events[EventName][SavedCommand] = (nil);
							Destroy(Button)
							SaveSettings();
						end,
					})
				end
			end

			local AddEvent = function() 
				if Settings.Events[SelectedEvent] and EventCommand then 
					local OldSelected = (SelectedEvent);
					local OldEvent = (EventCommand);

					Feature:AddEvent(OldSelected, OldEvent)
					Window:AddButton({
						Title = Format("Event for %s", SelectedEvent);
						Description = Format("Click to delete the event\nCommand: %s", EventCommand),
						Tab = "Current Events",
						Callback = function(Button) 
							Settings.Events[OldSelected][OldEvent] = (nil);
							Destroy(Button)
							SaveSettings();
						end,
					})
				else 
					API:Notify({
						Title = "Events",
						Description = "Error saving event, is one of the arguments missing?",
						Type = "Error",

						Duration = (10),
					})
				end
			end

			Window:AddButton({
				Title = "Create Event",
				Tab = "Create Event",
				Callback = AddEvent,
			})

			Window:AddDropdown({
				Title = "Select Event",
				Tab = "Create Event",
				Options = {
					["Auto Execute"] = "AutoExecute",
					["Chatted"] = "Chatted",
					["Respawned"] = "CharacterAdded",
					["Died"] = "Died",
					["Damaged"] = "Damaged",
					["Upon Leaving"] = "PlayerRemoved",
				},
				Callback = function(Event) 
					SelectedEvent = (Event);
				end,
			})

			Window:AddInput({
				Title = "Event Command",
				Tab = "Create Event",
				Callback = function(Input) 
					EventCommand = (Input);
				end,
			})

		end
	end,
})

Command.Add({
	Aliases = { "servers" },
	Description = "A tab that shows a list of servers in the game you're on",
	Arguments = {},
	Task = function()
		local Tab = Library.Tabs["Servers"];

		if Tab then
			Tab.Open()
		else
			local PlayerCount = (nil)
			local Refreshed = (false)
			local Window = Library:CreateWindow({
				Title = "Servers",
			})

			local LoadServers = function() 
				local Servers = Methods.Get(Format("https://games.robloxbadges.com/v1/games/%s/servers/Public?sortOrder=Desc&excludeFullGames=true&limit=100&cursor=", game.PlaceId));
				local Found = false 

				repeat Wait() 
					local Decode = JSONDecode(Services.Http, Servers);
					for Index, Server in next, Decode.data do 
						if typeof(Server) == "table" and (not PlayerCount or Server.playing == PlayerCount) then 
							Found = true

							Window:AddButton({
								Title = Server.id,
								Description = Format("Playing: %s\nPing: %s", Server.playing, Server.ping),
								Tab = "Home",
								Callback = function() 
									Services.Teleport:TeleportToPlaceInstance(game.PlaceId, Server.id, LocalPlayer)
								end,
							})
						end
					end

					if not Decode.nextPageCursor and not Found then
						API:Notify({
							Title = "Could not find server",
							Description = "Try a different player count!",
							Duration = 5,
							Type = "Error",
						})

						Found = true
					end 

					if not Found then 
						Servers = Methods.Get(Format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Desc&excludeFullGames=true&limit=100&cursor=%s", tostring(game.PlaceId), Decode.nextPageCursor or "" ));
					end
				until Found or Refreshed 

				Refreshed = false
			end

			Window:AddSection({ Title = "Settings", Tab = "Home" })

			Window:AddButton({
				Title = "Refresh",
				Tab = "Home",
				Callback = function() 
					for Index, Server in next, Window:GetTab("Home"):GetChildren() do
						if Server:IsA("TextButton") and Server.Frame.Title.Text:find("-") then
							Destroy(Server)
						end
					end

					LoadServers();
					Refreshed = true
				end,
			})

			Window:AddSlider({
				Title = "Player Count",
				Description = "(Set to 0 if you want to show all servers)",
				Tab = "Home",
				MaxValue = Services.Players.MaxPlayers,
				Callback = function(Amount) 
					if Amount == 0 then 
						PlayerCount = (nil);
					else 
						PlayerCount = Amount 
					end
				end,
			})

			Window:AddSection({ Title = "Servers", Tab = "Home" })
			LoadServers();
		end
	end,
})

Command.Add({
	Aliases = { "cmds", "commands" },
	Description = "Opens a tab that shows a list of the current commands",
	Arguments = {},
	Task = function()
		local Tab = Library.Tabs["Commands"];

		if Tab then
			Tab.Open()
		else
			local Window = Library:CreateWindow({
				Title = "Commands",
			})

			for Index, Command in next, Commands do
				local Aliases, Description, Arguments = Unpack(Command)
				local Args = "Arguments: " 

				Window:AddParagraph({
					Title = Concat(Aliases, " / ");
					Description = Description,
					Tab = "Home",
				})
			end
		end
	end,
})

Command.Add({
	Aliases = { "saveinstance", "savemap" },
	Description = "Saves an RBXL file of the game in your workspace folder",
	Arguments = {},
	Task = function()	
		if saveinstance then 
			saveinstance();
		else 
			return "Save Instance", "Your executor does not support save instance, missing function saveinstance()", 15
		end
	end,
})

Command.Add({
	Aliases = { "climb" },
	Description = "Climb in the air",
	Arguments = {},
	Task = function()	
		local oldPart = Get("ClimbPart")
		local Part = Create("TrussPart", {
			Transparency = 1,
			Size = Vector3.new(2, 10, 2),
			Parent = workspace,
			CanCollide = true,
			Name = GenerateGUID(Services.Http),
		})

		Add("ClimbPart", Part)
		if oldPart then
			Destroy(oldPart)
		end

		while (Part and Wait()) do
			Part.CFrame = Root.CFrame * CFrame.new(0, 0, -1.5)
		end
	end,
})

Command.Add({
	Aliases = { "unclimb" },
	Description = "Stops the climb command",
	Arguments = {},
	Task = function()		
		Destroy(Get("ClimbPart"))
	end,
})

Command.Add({
	Aliases = { "hipheight", "hh" },
	Description = "Set your character's hip height amount",
	Arguments = {
		{ Name = "Amount", Type = "Number" }
	},
	Task = function(Amount)
		Humanoid.HipHeight = SetNumber(Amount);
		return "Hip Height", Format("Set hip height to %s", Amount)
	end,
})

Command.Add({
	Aliases = { "spazz" },
	Description = "Similiar to spin",
	Arguments = {},
	Task = function()
		if Spazz then
			Destroy(Spazz)
		end

		Root.CFrame = Root.CFrame * CFrame.Angles(-0.3, 0, 0);
		Spazz = Create("BodyAngularVelocity", {
			P = 200000,
			AngularVelocity = Vector3.new(0, 15, 0),
			MaxTorque = Vector3.new(200000, 200000, 200000),
			Parent = Root
		})
	end,
})

Command.Add({
	Aliases = { "unspazz" },
	Description = "Stops the spazz command",
	Arguments = {},
	Task = function()
		if Spazz then
			Destroy(Spazz);
		end
	end,
})

Command.Add({
	Aliases = { "freezeanimations", "fan" },
	Description = "Freezes your animations in place",
	Arguments = {},
	Task = function()
		Character.Animate.Disabled = (true)
	end,
})

Command.Add({
	Aliases = { "unfreezeanimations", "unfan" },
	Description = "Unfreezes your animations",
	Arguments = {},
	Task = function()
		Character.Animate.Disabled = (false)
	end,
})

Command.Add({
	Aliases = { "goto", "to" },
	Description = "Teleports you to the target",
	Arguments = {
		{ Name = "Target", Type = "Player" }
	},
	Task = function(Input)
		Root.CFrame = GetRoot(GetPlayer(Input)[1]).CFrame
	end,
})

Command.Add({
	Aliases = { "scare" },
	Description = "Teleports you to the target for a second",
	Arguments = {
		{ Name = "Target", Type = "Player" },
	},
	Task = function(Input)
		local OldPosition = (Root.CFrame);
		Root.CFrame = GetRoot(GetPlayer(Input)[1]).CFrame
		Wait(1);
		Root.CFrame = OldPosition
	end,
})

Command.Add({
	Aliases = { "stare" },
	Description = "Stares at the target",
	Arguments = {
		{ Name = "Target", Type = "Player" }
	},
	Task = function(Input)
		local Target = GetPlayer(Input)[1]
		Refresh("Stare", true);

		repeat Wait();
			local TRoot = GetRoot(Target).Position
			Root.CFrame = CFrame.new(Root.Position, Vector3.new(TRoot.X, Root.Position.y, TRoot.Z))
		until not Get("Stare");
	end,
})

Command.Add({
	Aliases = { "unstare" },
	Description = "Undoes the stare command",
	Arguments = {},
	Task = function()
		Refresh("Stare", false);
	end,
})

Command.Add({
	Aliases = { "lay" },
	Description = "Makes you lay",
	Arguments = {},
	Task = function()
		Humanoid.Sit = (true);
		Root.CFrame = Root.CFrame * CFrame.Angles(1.5, 0, 0); Wait(.1);
		for Index, Track in next, Humanoid:GetPlayingAnimationTracks() do 
			Track:Stop() 
		end
	end,
})

Command.Add({
	Aliases = { "view", "spectate" },
	Description = "View your target",
	Arguments = {
		{ Name = "Target", Type = "Player" }
	},
	Task = function(Input)
		local Target = GetPlayer(Input)[1]
		Refresh("View", true)

		repeat Wait() 
			Camera.CameraSubject = GetHumanoid(Target)
		until not Get("View")
	end,
})

Command.Add({
	Aliases = { "unview", "unspectate" },
	Description = "Undoes the view command",
	Arguments = {},
	Task = function()
		Refresh("View", false)
		Camera.CameraSubject = (Humanoid)
	end,
})

Command.Add({
	Aliases = { "resetfilter", "ref" },
	Description = "If Roblox keeps tagging your messages, run this to reset the filter",
	Arguments = {},
	Task = function()
		for Index = 1, 3 do
			Services.Players:Chat(Format("/e hi"))
		end
		return "Filter", "Reset"
	end,
})

Command.Add({
	Aliases = { "fling" },
	Description = "Flings your target",
	Arguments = {
		{ Name = "Target", Type = "Player" }
	},
	Task = function(Input)
		local Targets = GetPlayer(Input)
		if #Targets == 0 then
			return "Fling", "No targets found"
		end

		local Successes = Fling(Targets)
		return "Fling", Format("Successfully flinged (%s/%s) player(s)", Successes, #Targets)
	end,
})

Command.Add({
	Aliases = { "loopfling", "lf" },
	Description = "Flings your target repeatedly",
	Arguments = {
		{ Name = "Target", Type = "Player" }
	},
	Task = function(Input)
		Refresh("Fling", true);
		repeat Fling(GetPlayer(Input))
		until not Get("Fling")
	end,
})

Command.Add({
	Aliases = { "unloopfling", "unlf" },
	Description = "Stops the loopfling command",
	Arguments = {},
	Task = function()
		Add("Fling", false);
	end,
})

-- :: SETUP :: --

if Check("File") then
	local LoadedPlugins = 0
	for Index, Folder in next, { "Cmd", "Cmd/Logs", "Cmd/Plugins" } do 
		if not isfolder(Folder) then 
			makefolder(Folder)
		end
	end

	Cmd().Build = {
		GetCharacter = GetCharacter,
		GetHumanoid = GetHumanoid,
		GetRoot = GetRoot,
		Chat = Chat,
		Library = Library,
		GetPlayer = GetPlayer,

		GlobalAdd = Add,
		GlobalGet = Get,
		GlobalRefresh = Refresh,

		Notify = function(Config) 
			return API:Notify(Config);
		end,
	}

	for Index, File in next, listfiles("Cmd/Plugins") do
		local Success, Plugin = pcall(function() 
			LoadedPlugins += 1
			return loadfile(File)();
		end)

		if Success then
			do
				for Index, PluginCommand in next, Plugin.Commands do
					Command.Add({
						Aliases = PluginCommand.Aliases or { "couldnt-get-aliases" },
						Description = PluginCommand.Description or "No description",
						Arguments = PluginCommand.Arguments or {},
						Plugin = true,
						Task = PluginCommand.Callback or function() 
							return "plugin command", "this plugin does not have a callback."
						end,
					})
				end

				API:Notify({
					Title = Plugin.Name,
					Description = Plugin.Description,
					Duration = 5,
					Type = "Info",
				})
			end
		else
			API:Notify({
				Title = File,
				Description = Plugin,
				Duration = (15),
				Type = "Warn",
			})
		end
	end
end

--// Autofill & Recommendation
for Index, Command in next, Commands do
	Fill.Add(Command);
end

Connect(Changed(Input, "Text"), function() 
	Fill.Search(Input.Text);
	Fill.Recommend(Input.Text);
end)

Connect(Services.Input.InputBegan, function(Key) 
	if Key.KeyCode == Enum.KeyCode.Tab and Press.Title.Text == ("Tab") and Services.Input:GetFocusedTextBox() == Input then
		local Text = Recommend.Text
		Wait();
		Input.Text = Text 
		Input.CursorPosition = #Text + 1;
	end
end)

--// Command Bar
local ChatDebounce = (false); --// for some reason chatted fires twice because of the chat bubble LOL

Connect(LocalPlayer.Chatted, function(Message) 
	if not ChatDebounce and Find(Message, Settings.ChatPrefix) then 
		ChatDebounce = (true);
		Command.Parse(false, Split(Message, Settings.ChatPrefix)[2]);
		Wait()
		ChatDebounce = (false);
	end
end)

Connect(Mouse.KeyDown, function(Key) 
	if Lower(Key) == Lower(Settings.Prefix) then
		local Transparency = (Settings.Theme.Transparency)
		local Padding = CommandBar.Parent:FindFirstChildOfClass("UIPadding")
		Wait();

		Input:CaptureFocus();
		BarShadow.Transparency = 1
		Padding.PaddingTop = UDim.new(0, -5)

		MultiSet(CommandBar, {
			GroupTransparency = 1,
			Visible = true,
			Position = UDim2.new(.5, 0, .5, -9);
		})

		Tween(BarShadow, .2, { Transparency = .9 });
		Tween(Padding, .2, { PaddingTop = UDim.new(0, 0) })
		Tween(CommandBar, .2, {
			GroupTransparency = (Transparency == 0) and .07 or (Settings.Theme.Transparency),
		}, { EasingDirection = Enum.EasingDirection.In, EasingStyle = Enum.EasingStyle.Linear })
	end
end)

Connect(Input.FocusLost, function() 
	local Padding = CommandBar.Parent:FindFirstChildOfClass("UIPadding")

	Command.Parse(false, Input.Text)
	Tween(BarShadow, .2, { Transparency = 1 });
	Tween(Padding, .2, { PaddingTop = UDim.new(0, 5) })
	Tween(CommandBar, .2, {
		GroupTransparency = 1,
	}, { EasingDirection = Enum.EasingDirection.In, EasingStyle = Enum.EasingStyle.Linear })

	Wait(.2)
	CommandBar.Visible = false
end)

do 
	local Interface = Cmd().UI 
	local API = Cmd().API 

	if Check("File") and not isfile("Cmd/Settings.json") then 
		SaveSettings()
	end

	Settings = GetSavedSettings() 

	if Settings.Toggles.Developer then
		if Interface then 
			Interface.Parent = nil
		end
	else 
		if Interface and API then
			UI.Parent = (nil);
			API:Notify({ 
				Title = "Already loaded",
				Description = "If you would like to reload Cmd rejoin or enable Developer mode!",
				Duration = 5,
				Type = "Error",
			})

			return
		end
	end

	SetTheme()
end

Spawn(function()  
	-- loading internal ui
	if Settings.Toggles.InternalUI then 
		loadstring(GetModule("internal-ui.lua"))()
	end

	-- staff notifier
	Connect(Services.Players.PlayerAdded, function(Player) 
		local StaffMember, Role = IsStaff(Player)
		if StaffMember and Settings.Toggles.StaffNotifier then 
			API:Notify({
				Title = "Staff Member has joined",
				Description = Format("Name: %s (@%s)\nRole: <b>%s</b>", Player.DisplayName, Player.Name, Role),
				Duration = 10,
				Type = "Warn",
			})
		end		
	end)

	local Staff = {}
	local ToSearch = Services.Players:GetPlayers()
	local Searched = 0

	for Index, Player in next, ToSearch do
		Spawn(function()  -- since getroleingroup is slow we adding a spawn to make it faster
			if Player ~= LocalPlayer and IsStaff(Player) and UI.Parent and Settings.Toggles.StaffNotifier then 
				Insert(Staff, Player.Name)
			end
			Searched += 1
		end)
	end 

	repeat 
		Wait();
	until (Searched == #ToSearch)

	if #Staff > 0 then 
		API:Notify({
			Title = "Staff Detected!",
			Description = Format("We have found <b>%s</b> staff member(s) in your game! (%s)", tostring(#Staff), Concat(Staff, " , ")),
			Duration = 20,
			Type = "Warn",
		})
	end

	if (not Drawing) then 
		Drawing = loadstring(GetModule("drawing.lua"))();
	end
end)

Cmd().UI = (UI);
Cmd().API = (API);

Spawn(function()
	if not Character then 
		repeat Wait();
		until Character and Humanoid
	end

	local OldHealth = (Humanoid and Humanoid.Health);

	Feature:ConnectEvent("PlayerRemoved")
	Feature:ConnectEvent("AutoExecute")
	Feature:ConnectEvent("Chatted", LocalPlayer.Chatted);
	Feature:ConnectEvent("CharacterAdded", LocalPlayer.CharacterAdded);
	Feature:ConnectEvent("Died", nil, true);
	Feature:ConnectEvent("Damaged", nil, true, function(Humanoid) 
		if (not OldHealth) or (Humanoid.Health <= OldHealth) then 
			return true
		end

		OldHealth = (Humanoid.Health);
	end);
end)